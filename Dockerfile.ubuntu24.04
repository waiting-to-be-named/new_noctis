# NOCTIS DICOM Viewer - Ubuntu 24.04.2 Dockerfile
# Optimized for production deployment

FROM ubuntu:24.04

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV DJANGO_SETTINGS_MODULE=noctisview.settings

# Install system dependencies
RUN apt-get update && apt-get install -y \
    python3.12 \
    python3.12-dev \
    python3-pip \
    python3-venv \
    build-essential \
    libssl-dev \
    libffi-dev \
    libjpeg-dev \
    libpng-dev \
    libtiff-dev \
    libopenexr-dev \
    libwebp-dev \
    libopenjp2-7-dev \
    libgdal-dev \
    libgeos-dev \
    libproj-dev \
    libspatialindex-dev \
    postgresql-client \
    redis-tools \
    nginx \
    curl \
    wget \
    git \
    htop \
    iotop \
    nethogs \
    fail2ban \
    ufw \
    logrotate \
    rsyslog \
    && rm -rf /var/lib/apt/lists/*

# Create application user
RUN useradd --system --group --home /opt/noctis noctis

# Create application directory
RUN mkdir -p /opt/noctis && chown noctis:noctis /opt/noctis

# Set working directory
WORKDIR /opt/noctis

# Copy requirements first for better caching
COPY requirements.txt .

# Create virtual environment and install Python dependencies
RUN python3 -m venv /opt/noctis/venv
ENV PATH="/opt/noctis/venv/bin:$PATH"

# Upgrade pip and install dependencies
RUN pip install --upgrade pip setuptools wheel
RUN pip install -r requirements.txt
RUN pip install gunicorn psycopg2-binary whitenoise redis celery

# Copy application code
COPY . .

# Create necessary directories
RUN mkdir -p /opt/noctis/logs \
    /opt/noctis/media/dicom_files \
    /opt/noctis/staticfiles \
    /opt/noctis/temp \
    /opt/noctis/backup

# Set proper permissions
RUN chown -R noctis:noctis /opt/noctis
RUN chmod -R 755 /opt/noctis/media \
    /opt/noctis/staticfiles \
    /opt/noctis/logs \
    /opt/noctis/temp

# Create Gunicorn configuration
RUN cat > /opt/noctis/gunicorn.conf.py << 'EOF'
import multiprocessing
import os

# Server socket
bind = "0.0.0.0:8000"
backlog = 2048

# Worker processes
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
max_requests = 1000
max_requests_jitter = 100
timeout = 300
keepalive = 2
preload_app = True

# Logging
accesslog = "/opt/noctis/logs/gunicorn_access.log"
errorlog = "/opt/noctis/logs/gunicorn_error.log"
loglevel = "info"
access_log_format = '%(h)s %(l)s %(u)s %(t)s "%(r)s" %(s)s %(b)s "%(f)s" "%(a)s"'

# Process naming
proc_name = "noctis"

# Server mechanics
daemon = False
pidfile = "/opt/noctis/gunicorn.pid"
user = "noctis"
group = "noctis"
tmp_upload_dir = None
secure_scheme_headers = {"X-FORWARDED-PROTO": "https"}

# Server hooks
def on_starting(server):
    server.log.info("Starting Noctis DICOM Server")

def on_reload(server):
    server.log.info("Reloading Noctis DICOM Server")

def worker_int(worker):
    worker.log.info("worker received INT or QUIT signal")

def pre_fork(server, worker):
    server.log.info("Worker spawned (pid: %s)", worker.pid)

def post_fork(server, worker):
    server.log.info("Worker spawned (pid: %s)", worker.pid)

def post_worker_init(worker):
    worker.log.info("Worker initialized (pid: %s)", worker.pid)

def worker_abort(worker):
    worker.log.info("Worker aborted (pid: %s)", worker.pid)
EOF

# Create Nginx configuration
RUN cat > /etc/nginx/sites-available/noctis << 'EOF'
# Rate limiting
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=upload:10m rate=2r/s;

# Upstream for load balancing
upstream noctis_backend {
    server 127.0.0.1:8000;
}

# HTTP to HTTPS redirect
server {
    listen 80;
    server_name _;
    return 301 https://$server_name$request_uri;
}

# HTTPS server
server {
    listen 443 ssl http2;
    server_name _;

    # SSL configuration (self-signed for container)
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin";

    # File upload limits
    client_max_body_size 2G;
    client_body_timeout 300s;
    client_header_timeout 60s;

    # Proxy settings
    proxy_connect_timeout 75s;
    proxy_read_timeout 300s;
    proxy_send_timeout 300s;
    proxy_buffering off;
    proxy_request_buffering off;

    # Main application
    location / {
        limit_req zone=api burst=20 nodelay;
        
        proxy_pass http://noctis_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
    }

    # File upload endpoint
    location /upload/ {
        limit_req zone=upload burst=5 nodelay;
        
        proxy_pass http://noctis_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Static files
    location /static/ {
        alias /opt/noctis/staticfiles/;
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header X-Content-Type-Options nosniff;
        
        # Gzip compression
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_proxied any;
        gzip_comp_level 6;
        gzip_types
            text/plain
            text/css
            text/xml
            text/javascript
            application/json
            application/javascript
            application/xml+rss
            application/atom+xml
            image/svg+xml;
    }

    # Media files
    location /media/ {
        alias /opt/noctis/media/;
        expires 1y;
        add_header Cache-Control "public";
        add_header X-Content-Type-Options nosniff;
        
        # Security for DICOM files
        location ~* \.(dcm|dicom)$ {
            add_header Content-Disposition "attachment";
        }
    }

    # Health check
    location /health/ {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Deny access to sensitive files
    location ~ /\. {
        deny all;
    }
    
    location ~ \.(env|py|pyc|pyo|pyd|log|sql|db|bak|old|tmp)$ {
        deny all;
    }
}
EOF

# Enable Nginx site
RUN ln -sf /etc/nginx/sites-available/noctis /etc/nginx/sites-enabled/ && \
    rm -f /etc/nginx/sites-enabled/default

# Generate self-signed SSL certificate
RUN openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/ssl/private/nginx-selfsigned.key \
    -out /etc/ssl/certs/nginx-selfsigned.crt \
    -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"

# Create startup script
RUN cat > /opt/noctis/start.sh << 'EOF'
#!/bin/bash
set -e

echo "Starting Noctis DICOM Viewer..."

# Activate virtual environment
source /opt/noctis/venv/bin/activate

# Wait for database (if using external database)
if [ "$DB_HOST" != "" ]; then
    echo "Waiting for database..."
    while ! pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER; do
        sleep 2
    done
fi

# Run migrations
echo "Running database migrations..."
python manage.py migrate --noinput

# Collect static files
echo "Collecting static files..."
python manage.py collectstatic --noinput

# Start DICOM SCP server in background
echo "Starting DICOM SCP server..."
python enhanced_scp_server.py &

# Start Gunicorn
echo "Starting Gunicorn..."
exec gunicorn -c gunicorn.conf.py noctisview.wsgi:application
EOF

RUN chmod +x /opt/noctis/start.sh

# Create health check script
RUN cat > /opt/noctis/healthcheck.sh << 'EOF'
#!/bin/bash
# Health check for the application
curl -f http://localhost:8000/health/ || exit 1
EOF

RUN chmod +x /opt/noctis/healthcheck.sh

# Expose ports
EXPOSE 80 443 8000 11112

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD /opt/noctis/healthcheck.sh

# Set user
USER noctis

# Default command
CMD ["/opt/noctis/start.sh"]